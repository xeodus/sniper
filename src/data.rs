use crate::{
    db::Database, notification::NotificationService, position_manager::PositionManager,
    rest_client::BinanceClient, signal::MarketSignal,
};
use rust_decimal::Decimal;
use serde::Deserialize;
use std::sync::Arc;
use tokio::sync::{mpsc, RwLock};

/// Position side - Long (buy) or Short (sell)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PositionSide {
    Long,
    Short,
}

/// Order side - Buy, Sell, or Hold
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Side {
    Buy,
    Sell,
    Hold,
}

/// Order type - Market or Limit
#[derive(Debug, Clone, PartialEq, Eq)]
#[allow(dead_code)]
pub enum OrderType {
    Market,
    Limit,
}

/// Market trend direction
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Trend {
    Up,
    Down,
    Sideways,
}

/// Trading position
#[derive(Debug, Clone)]
pub struct Position {
    pub id: String,
    pub symbol: String,
    pub position_side: PositionSide,
    pub entry_price: Decimal,
    pub size: Decimal,
    pub stop_loss: Decimal,
    pub take_profit: Decimal,
    pub opened_at: i64,
}

/// OHLCV candlestick data
#[derive(Debug, Clone)]
pub struct Candles {
    pub open: Decimal,
    pub high: Decimal,
    pub low: Decimal,
    pub close: Decimal,
    pub volume: Decimal,
    pub timestamp: i64,
}

/// Order request structure
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct OrderReq {
    pub id: String,
    pub symbol: String,
    pub side: Side,
    pub order_type: OrderType,
    pub price: Decimal,
    pub size: Decimal,
    pub sl: Option<Decimal>,
    pub tp: Option<Decimal>,
    pub manual: bool,
}

/// Trading signal generated by analysis
#[derive(Debug, Clone, PartialEq)]
pub struct Signal {
    pub id: String,
    pub timestamp: i64,
    pub symbol: String,
    pub action: Side,
    pub price: Decimal,
    pub trend: Trend,
    pub confidence: Decimal,
}

/// Main trading bot structure
pub struct TradingBot {
    pub analyzer: Arc<RwLock<MarketSignal>>,
    pub position_manager: Arc<PositionManager>,
    pub binance_client: Arc<BinanceClient>,
    pub signal_tx: mpsc::Sender<Signal>,
    pub order_tx: mpsc::Sender<OrderReq>,
    pub account_balance: Arc<RwLock<Decimal>>,
    pub db: Arc<Database>,
    pub notification: Arc<NotificationService>,
}

/// Binance kline (candlestick) data from WebSocket
#[derive(Debug, Clone, Deserialize)]
#[allow(dead_code)]
pub struct BinanceKline {
    #[serde(rename = "t")]
    pub open_time: i64,
    #[serde(rename = "o")]
    pub open: String,
    #[serde(rename = "h")]
    pub high: String,
    #[serde(rename = "l")]
    pub low: String,
    #[serde(rename = "c")]
    pub close: String,
    #[serde(rename = "v")]
    pub volume: String,
    #[serde(rename = "x")]
    pub is_closed: bool,
}

/// Binance kline event wrapper from WebSocket
#[derive(Debug, Clone, Deserialize)]
#[allow(dead_code)]
pub struct BinanceKlineEvent {
    #[serde(rename = "e")]
    pub event_type: String,
    #[serde(rename = "E")]
    pub event_time: i64,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "k")]
    pub kline: BinanceKline,
}

impl std::fmt::Display for Side {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Side::Buy => write!(f, "Buy"),
            Side::Sell => write!(f, "Sell"),
            Side::Hold => write!(f, "Hold"),
        }
    }
}

impl std::fmt::Display for PositionSide {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PositionSide::Long => write!(f, "Long"),
            PositionSide::Short => write!(f, "Short"),
        }
    }
}

impl std::fmt::Display for Trend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Trend::Up => write!(f, "Up"),
            Trend::Down => write!(f, "Down"),
            Trend::Sideways => write!(f, "Sideways"),
        }
    }
}
